// Generated by CoffeeScript 1.9.1

/*
The ECHOQuery contains basic query methods used by the SDK.
 */

(function () {
  var ECHO,
    ECHOContentsObject,
    ECHODataObject,
    ECHODistributedObject,
    ECHOObject,
    ECHOQuery,
    ECHOTreeMap,
    dateFromString,
    stringFromDate,
    typeIsArray,
    typeIsString,
    extend = function (child, parent) { for (const key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ECHOQuery = (function () {
    function ECHOQuery() {}


    /*
    	Does Find objects from the remote server.

    	@param [String] instanceId the reference ID of the finding target instance
    	@param [String] resourceType the type of this object
    	@param [Object] params to control the output
     */

    ECHOQuery.find = function (instanceId, resourceType, params, listKey) {
      let promise,
        promise2;
      promise = ECHOQuery.request('GET', `/${instanceId}/${resourceType}`, params);
      promise2 = new ECHO.Promise();
      promise.then(((retObj) => {
        let j,
          len,
          obj,
          objList,
          ref;
        if ((retObj != null ? retObj[listKey] : void 0) == null) {
          return promise2.reject(new Error(`Invalid data type for response-field \`${listKey}\`.`));
        }
        objList = new ECHO.List(retObj.paginate);
        ref = retObj[listKey];
        for (j = 0, len = ref.length; j < len; j++) {
          obj = ref[j];
          objList.push(ECHODataObject.factory(obj));
        }
        return promise2.resolve(objList);
      }), (error => promise2.reject(error)));
      return promise2;
    };


    /*
    	Sends a HTTP request with optional request contents/parameters.

    	@param [String] method
    	@param [String] path
    	@param [Object] data
    	@param [boolean] multipart
     */

    ECHOQuery.request = function (method, path, data, multipart) {
      let FormData,
        buildRequestContents,
        data2,
        flag,
        formData,
        makeQueryString,
        promise,
        query,
        reqMethod,
        xhr;
      if (multipart == null) {
        multipart = false;
      }
      if (typeof module !== 'undefined' && module !== null ? module.exports : void 0) {
        FormData = require('form-data');
      } else {
        FormData = window.FormData;
      }
      promise = new ECHO.Promise();
      xhr = new XMLHttpRequest();
      flag = 0;
      xhr.onreadystatechange = function () {
        let detail,
          e,
          errorObj,
          key,
          ref,
          res;
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            flag = 1;
          } else if (xhr.status) {
            flag = -1;
          }
          if (flag !== 0) {
            try {
              res = JSON.parse(xhr.responseText);
            } catch (_error) {
              e = _error;
              if (flag === 1) {
                promise.reject(new ECHO.Error(ECHO.Error.INVALID_JSON_FORMAT, 'Invalid JSON format.'));
              } else {
                promise.reject(new Error(xhr.responseText));
              }
              return null;
            }
            if (flag === 1) {
              promise.resolve(res);
            } else {
              if ((res.error_code != null) && (res.error_message != null)) {
                errorObj = new ECHO.Error(res.error_code, res.error_message);
                if ((res.error_details != null) && res.error_details instanceof Object) {
                  ref = res.error_details;
                  for (key in ref) {
                    detail = ref[key];
                    if ((key != null) && (detail.error_code != null) && (detail.error_message != null)) {
                      errorObj.setErrorDetail(key, detail.error_code, detail.error_message);
                    }
                  }
                }
              } else {
                errorObj = new Error('An unknown error has occurred.');
              }
              promise.reject(errorObj);
            }
            return null;
          }
        }
      };
      reqMethod = multipart ? 'POST' : method;
      makeQueryString = function (obj) {
        let key,
          str,
          val,
          val2;
        str = '?';
        for (key in obj) {
          val = obj[key];
          if (val instanceof Object) {
            val2 = JSON.stringify(val);
          } else {
            val2 = val;
          }
          str += `${key}=${val2}&`;
        }
        return str.substr(0, str.length - 1);
      };
      query = method === 'GET' ? makeQueryString(data) : '';
      xhr.open(reqMethod, `https://${ECHO.secureDomain}${path}/rest_api=1.0/${query}`, true);
      if (!((ECHO.appId != null) && (ECHO.appKey != null))) {
        throw new Error('The SDK is not initialized. Please call `ECHO.initialize()`.');
      }
      xhr.setRequestHeader('X-ECHO-APP-ID', ECHO.appId);
      xhr.setRequestHeader('X-ECHO-APP-KEY', ECHO.appKey);
      if (ECHO.accessToken != null) {
        xhr.setRequestHeader('X-ECHO-ACCESS-TOKEN', ECHO.accessToken);
      }
      if (multipart) {
        buildRequestContents = function (data, currentKeys, formData) {
          let boundary,
            content,
            filename,
            i,
            j,
            k,
            key,
            l,
            len,
            len1,
            name,
            newKeys,
            ref,
            val;
          if (!(data instanceof Object)) {
            return null;
          }
          for (key in data) {
            val = data[key];
            newKeys = [];
            for (j = 0, len = currentKeys.length; j < len; j++) {
              k = currentKeys[j];
              newKeys.push(k);
            }
            newKeys.push(key);
            name = '';
            for (i = l = 0, len1 = newKeys.length; l < len1; i = ++l) {
              k = newKeys[i];
              name += i === 0 ? k : `[${k}]`;
            }
            if (val instanceof ECHO.File) {
              filename = (ref = val.name) != null ? ref : 'blob';
              if (typeof module !== 'undefined' && module !== null ? module.exports : void 0) {
                boundary = `--${formData.getBoundary()}`;
                formData.append(name, val.file, {
                  header: `${boundary}\r\n` + `Content-Disposition: form-data; name="${name}"; filename="${filename}"\r\n` + `Content-Type: ${val.getMimeType()}\r\n\r\n`,
                });
              } else {
                formData.append(name, val.file, filename);
              }
            } else if (val instanceof Object) {
              buildRequestContents(val, newKeys, formData);
            } else if (val != null) {
              content = '';
              if (val instanceof Boolean) {
                content = val ? 'true' : '';
              } else {
                content = val;
              }
              formData.append(name, content);
            }
          }
          return null;
        };
        data2 = {};
        data2.method = method;
        data2.data = data;
        formData = new FormData();
        buildRequestContents(data2, [], formData);
        xhr.send(formData);
      } else {
        xhr.setRequestHeader('Content-Type', 'application/json');
        data = JSON.stringify(data || {});
        xhr.send(data);
      }
      return promise;
    };

    return ECHOQuery;
  }());


  /*
  An ECHOObject is an abstract object.
  Particular objects are implemented based on this class.
   */

  ECHOObject = (function () {
    ECHOObject.prototype.instanceId = null;

    ECHOObject.prototype.resourceType = null;

    ECHOObject.prototype.refid = null;


    /*
    	Constructs a new ECHOObject.

    	@param [String] instanceId the reference ID of the instance to which this object belongs
    	@param [String] resourceType the type of this object
    	@param [String] refid the reference ID of the existing one
     */

    function ECHOObject(instanceId1, resourceType1, refid1) {
      this.instanceId = instanceId1;
      this.resourceType = resourceType1;
      this.refid = refid1 != null ? refid1 : null;
    }


    /*
    	Returns the request URL path.
     */

    ECHOObject.prototype.getRequestUrl = function () {
      let path;
      path = `/${this.instanceId}/${this.resourceType}`;
      if (this.refid != null) {
        path += `/${this.refid}`;
      }
      return path;
    };

    return ECHOObject;
  }());


  /*
  An ECHODataObject is an abstract data object.
  Particular data objects are implemented based on this class.
   */

  ECHODataObject = (function (superClass) {
    extend(ECHODataObject, superClass);


    /*
    	Factory method of particular data objects.

    	@param [Object] data a source object
    	@return [? extends ECHODataObject]
     */

    ECHODataObject.factory = function (data) {
      let instanceId,
        obj,
        ref,
        ref1,
        ref2,
        refid,
        resourceType,
        sUrl;
      refid = (ref = data != null ? data.refid : void 0) != null ? ref : null;
      resourceType = (ref1 = data != null ? data.resource_type : void 0) != null ? ref1 : null;
      sUrl = data != null ? (ref2 = data.url_path) != null ? ref2.split('/') : void 0 : void 0;
      if ((sUrl != null ? sUrl[1] : void 0) != null) {
        instanceId = sUrl[1];
      }
      if ((refid == null) || !refid) {
        return null;
      }
      if ((instanceId == null) || !instanceId) {
        return null;
      }
      obj = null;
      switch (resourceType) {
        case 'entry':
          obj = new ECHO.Blogs.EntryObject(instanceId, refid, data);
          break;
        case 'record':
          obj = new ECHO.Databases.RecordObject(instanceId, refid, data);
          break;
        case 'member':
          obj = new ECHO.Members.MemberObject(instanceId, refid, data);
      }
      return obj;
    };


    /*
    	Constructs a new ECHODataObject based on an existing one on the remote server.

    	@param [String] instanceId the reference ID of the instance to which the object has belonged
    	@param [String] resourceType the type of this object
    	@param [String] refid the reference ID of the existing one
    	@param [Object] data a source object to copy
     */

    function ECHODataObject(instanceId, resourceType, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      ECHODataObject.__super__.constructor.call(this, instanceId, resourceType, refid);
      this._data = {};
      this._newACL = null;
      this._currentACL = null;
      this._multipart = false;
      if (data != null) {
        this._copyData(data);
      }
    }


    /*
    	<span class="en">Fetches data from the remote server in a background thread.</span>
    	<span class="ja">非同期通信によるデータ取得。</span>

    	@return [ECHO.Promise]
     */

    ECHODataObject.prototype.fetch = function () {
      let promise,
        promise2;
      promise = ECHOQuery.request('GET', this.getRequestUrl(), null);
      promise2 = new ECHO.Promise();
      promise.then(((function (_this) {
        return function (retObj) {
          _this._copyData(retObj);
          return promise2.resolve(_this);
        };
      })(this)), (error => promise2.reject(error)));
      return promise2;
    };


    /*
    	<span class="en">Pushes data to the remote server in a background thread.</span>
    	<span class="ja">非同期通信による保存。</span>

    	@return [ECHO.Promise]
    	@throw [ECHO.Error] Errors in local validation
     */

    ECHODataObject.prototype.push = function () {
      let data,
        method,
        promise,
        promise2;
      data = this._buildRequestContents();
      method = this.refid ? 'PUT' : 'POST';
      promise = ECHOQuery.request(method, this.getRequestUrl(), data, this._multipart);
      promise2 = new ECHO.Promise();
      promise.then(((function (_this) {
        return function (retObj) {
          _this._copyData(retObj);
          _this.refid = retObj.refid;
          return promise2.resolve(_this);
        };
      })(this)), (error => promise2.reject(error)));
      return promise2;
    };


    /*
    	<span class="en">Deletes an object from the remote server in a background thread.</span>
    	<span class="ja">非同期通信による削除。</span>

    	@return [ECHO.Promise]
     */

    ECHODataObject.prototype.delete = function () {
      let promise,
        promise2;
      promise = ECHOQuery.request('DELETE', this.getRequestUrl(), null);
      promise2 = new ECHO.Promise();
      promise.then(((function (_this) {
        return function (retObj) {
          _this.refid = null;
          return promise2.resolve(_this);
        };
      })(this)), (error => promise2.reject(error)));
      return promise2;
    };


    /*
    	Returns the value mapped by key, or null if no such mapping exists.

    	@param [String] key
    	@return [Object]
     */

    ECHODataObject.prototype.get = function (key) {
      let nestedGet;
      nestedGet = (function (_this) {
        return function (obj, keys) {
          key = keys.shift();
          if (obj[key] instanceof Object && keys.length > 0) {
            return nestedGet(obj[key], keys);
          }
          return obj[key];
        };
      }(this));
      return nestedGet(this._data, key.split('.'));
    };


    /*
    	Maps key to value, clobbering any existing key/value mapping with the same key.

    	@param [String] key
    	@param [Object] value
     */

    ECHODataObject.prototype.put = function (key, value) {
      let nestedPut;
      this._data[key] = value;
      return null;
      nestedPut = (function (_this) {
        return function (obj, keys, val) {
          key = keys.shift();
          if (obj instanceof Object && keys.length > 0) {
            if (obj[key] != null) {
              obj[key] = {};
            }
            return nestedPut(obj[key], keys, val);
          }
          return obj = val;
        };
      }(this));
      nestedPut(this._data, key.split('.', value));
      console.log('----------------');
      console.log(key);
      console.log(value);
      return console.log(this._data);
    };


    /*
    	<span class="en">Gets the current ACLObject of this object</span>
    	<span class="ja">このオブジェクトに設定されているACLを取得する。</span>

    	@return [ECHO.ACL]
     */

    ECHODataObject.prototype.getACL = function () {
      return this._currentACL;
    };


    /*
    	<span class="en">Sets the new ACLObject.</span>
    	<span class="ja">新しいACLをセットする。サーバーへ反映させるには、保存処理を行ってください。</span>

    	@param [ECHO.ACL] newACL
     */

    ECHODataObject.prototype.setNewACL = function (newACL) {
      return this._newACL = newACL;
    };


    /*
    	Copies data from an object

    	@private
    	@param [Object] data the source object
     */

    ECHODataObject.prototype._copyData = function (data) {
      let ignored,
        j,
        key,
        key2,
        len,
        ref,
        val,
        val2;
      if (!(data instanceof Object)) {
        return null;
      }
      if (data.created != null) {
        try {
          data.created = dateFromString(data.created);
        } catch (_error) {
          ignored = _error;
        }
      }
      if (data.modified != null) {
        try {
          data.modified = dateFromString(data.modified);
        } catch (_error) {
          ignored = _error;
        }
      }
      if (data.acl instanceof Object) {
        this._currentACL = new ECHO.ACL(data.acl);
        delete data.acl;
      }
      if (data.contents instanceof Object) {
        ref = data.contents;
        for (key in ref) {
          val = ref[key];
          if (typeIsArray(val)) {
            for (key2 = j = 0, len = val.length; j < len; key2 = ++j) {
              val2 = val[key2];
              data.contents[key][key2] = this._convertContentsInCopyData(val2);
            }
          } else {
            data.contents[key] = this._convertContentsInCopyData(val);
          }
        }
      }
      this._data = data;
      return null;
    };

    ECHODataObject.prototype._convertContentsInCopyData = function (val) {
      let file,
        ignored;
      if ((val != null ? val._type : void 0) != null) {
        switch (val._type) {
          case 'file':
            file = new ECHO.File();
            file.setRemoteFile(val);
            return file;
          case 'instance':
            return ECHODataObject.factory(val);
        }
      } else if (typeIsString(val) && val.length === 19) {
        try {
          return dateFromString(val);
        } catch (_error) {
          ignored = _error;
        }
      }
      return val;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
    	@throw [ECHO.Error] Errors in local validation
     */

    ECHODataObject.prototype._buildRequestContents = function () {
      let data,
        j,
        key,
        key2,
        key3,
        len,
        ref,
        ref1,
        val,
        val2,
        val3;
      this._multipart = false;
      data = {};
      if (this._newACL != null) {
        data.acl = (ref = this._newACL) != null ? typeof ref.toObject === 'function' ? ref.toObject() : void 0 : void 0;
      }
      ref1 = this._data;
      for (key in ref1) {
        val = ref1[key];
        if (key === 'modified' || key === 'created') {
          continue;
        } else if (key === 'contents') {
          if (!(val instanceof Object)) {
            continue;
          }
          data.contents = {};
          for (key2 in val) {
            val2 = val[key2];
            if (typeIsArray(val2)) {
              data.contents[key2] = [];
              for (key3 = j = 0, len = val2.length; j < len; key3 = ++j) {
                val3 = val2[key3];
                data.contents[key2][key3] = this._convertContentsInBuildRequest(val3);
              }
            } else {
              data.contents[key2] = this._convertContentsInBuildRequest(val2);
            }
          }
        } else {
          data[key] = val;
        }
      }
      return data;
    };

    ECHODataObject.prototype._convertContentsInBuildRequest = function (val) {
      if (val instanceof ECHO.File) {
        if (val.file != null) {
          this._multipart = true;
        } else {
          return null;
        }
      } else if (val instanceof ECHODataObject) {
        if (val.refid != null) {
          return val.refid;
        }
        return null;
      } else if (val instanceof Date) {
        val = stringFromDate(val);
      }
      return val;
    };

    return ECHODataObject;
  }(ECHOObject));


  /*
  An ECHOContentsObject is an abstract contents object.
   */

  ECHOContentsObject = (function (superClass) {
    extend(ECHOContentsObject, superClass);

    function ECHOContentsObject() {
      return ECHOContentsObject.__super__.constructor.apply(this, arguments);
    }


    /*
    	Copies data from an object.

    	@private
    	@param [Object] data the source object
     */

    ECHOContentsObject.prototype._copyData = function (data) {
      let category,
        i,
        j,
        len,
        ref;
      if (data.categories == null) {
        return null;
      }
      ref = data.categories;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        category = ref[i];
        if (category.refid != null) {
          data.categories[i] = new ECHO.ContentsCategoryObject(this.instanceId, category.refid, category);
        }
      }
      ECHOContentsObject.__super__._copyData.call(this, data);
      return null;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
    	@throw [ECHO.Error] Errors in local validation
     */

    ECHOContentsObject.prototype._buildRequestContents = function () {
      let category,
        data,
        i,
        j,
        len,
        ref;
      data = ECHOContentsObject.__super__._buildRequestContents.call(this);
      if (data.categories != null) {
        ref = data.categories;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          category = ref[i];
          if (category.refid != null) {
            data.categories[i] = category.refid;
          }
        }
      }
      return data;
    };

    return ECHOContentsObject;
  }(ECHODataObject));


  /*
  An ECHOTreeMap is an abstract recursive tree map.
  Particular tree maps are implemented based on this class.
   */

  ECHOTreeMap = (function (superClass) {
    extend(ECHOTreeMap, superClass);

    ECHOTreeMap.prototype.node = null;

    ECHOTreeMap.prototype.children = null;


    /*
    	Constructs a new ECHOTreeMap.

    	@param [string] instanceId the reference ID of the instance to which the tree map has belonged
    	@param [string] resourceType the type of this object
    	@param [string] refid the reference ID of the root node of the existing sub one
    	@param [Object] data
     */

    function ECHOTreeMap(instanceId, resourceType, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      ECHOTreeMap.__super__.constructor.call(this, instanceId, resourceType, refid);
      this._isSubtree = refid != null;
      if (data != null) {
        this._copyData(data);
      }
    }


    /*
    	Does Fetch data from the remote server in a background thread.

    	@return [ECHO.Promise]
     */

    ECHOTreeMap.prototype.fetch = function () {
      let promise,
        promise2;
      promise = ECHOQuery.request('GET', this.getRequestUrl(), null);
      promise2 = new ECHO.Promise();
      promise.then(((function (_this) {
        return function (retObj) {
          _this._copyData(retObj);
          return promise2.resolve(_this);
        };
      })(this)), (error => promise2.reject(error)));
      return promise2;
    };

    return ECHOTreeMap;
  }(ECHOObject));


  /*
  An ECHODistributedObject is an abstract distributed object.
   */

  ECHODistributedObject = (function (superClass) {
    extend(ECHODistributedObject, superClass);

    function ECHODistributedObject() {
      return ECHODistributedObject.__super__.constructor.apply(this, arguments);
    }


    /*
    	<span class="en">Resets the target object.</span>
    	<span class="ja">送信ターゲットをリセットします。</span>
     */

    ECHODistributedObject.prototype.resetTarget = function () {
      return this._data.target = {};
    };


    /*
    	<span class="en">Adds all members to the target to send.</span>
    	<span class="ja">すべてのメンバーを送信ターゲットに追加します。</span>
     */

    ECHODistributedObject.prototype.targetAllMembers = function () {
      return this._data.target = {
        members: '*',
      };
    };


    /*
    	<span class="en">Adds the root group (all groups) to the target to send.</span>
    	<span class="ja">ルートグループ（すべてのグループ）を送信ターゲットに追加します。</span>
     */

    ECHODistributedObject.prototype.targetRootGroup = function () {
      if (this._data.target == null) {
        this._data.target = {};
      }
      return this._data.target.groups = '*';
    };


    /*
    	<span class="en">Adds a specific member to the target to send.</span>
    	<span class="ja">特定のメンバーを送信ターゲットに追加します。</span>
    	@param [ECHO.Members.MemberObject] member a member object
    	@throw [TypeError]
     */

    ECHODistributedObject.prototype.targetSpecificMember = function (member) {
      if (!(member instanceof ECHO.Members.MemberObject && (member.instanceId != null) && member.instanceId && (member.refid != null) && member.refid)) {
        throw new TypeError('Invalid data type for argument `member`.');
      }
      if (this._data.target == null) {
        this._data.target = {};
      }
      if (!(typeIsArray(this._data.target.members != null))) {
        this._data.target.members = [];
      }
      return this._data.target.members.push(member);
    };


    /*
    	<span class="en">Adds a specific group to the target to send.</span>
    	<span class="ja">特定のグループを送信ターゲットに追加します。</span>
    	@param [ECHO.Members.GroupObject] group a group object
    	@throw [TypeError]
     */

    ECHODistributedObject.prototype.targetSpecificGroup = function (group) {
      if (!(group instanceof ECHO.Members.GroupObject && (group.instanceId != null) && group.instanceId && (group.refid != null) && group.refid)) {
        throw new TypeError('Invalid data type for argument `group`.');
      }
      if (this._data.target == null) {
        this._data.target = {};
      }
      if (!(typeIsArray(this._data.target.groups != null))) {
        this._data.target.groups = [];
      }
      return this._data.target.groups.push(group);
    };


    /*
    	Copies data from an object.

    	@private
    	@param [Object] data the source object
     */

    ECHODistributedObject.prototype._copyData = function (data) {
      let i,
        j,
        l,
        len,
        len1,
        ref,
        ref1,
        refid,
        targetGroups,
        targetMembers;
      if (data.distributed != null) {
        data.distributed = dateFromString(data.distributed);
      }
      if (data.target != null) {
        if (typeIsArray(data.target.members)) {
          targetMembers = [];
          ref = data.target.members;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            refid = ref[i];
            if (refid === '*') {
              data.target.members = '*';
              break;
            } else if (refid.length > 0) {
              targetMembers.push(new ECHO.Members.MemberObject(this.instanceId, refid));
            }
          }
          data.target.members = targetMembers;
        } else if (data.target.members === '*') {
          data.target.members = '*';
        }
        if (typeIsArray(data.target.groups)) {
          targetGroups = [];
          ref1 = data.target.groups;
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            refid = ref1[i];
            if (refid === '*') {
              data.target.groups = '*';
              break;
            } else if (refid.length > 0) {
              targetGroups.push(new ECHO.Members.GroupObject(this.instanceId, refid));
            }
          }
          data.target.groups = targetGroups;
        } else if (data.target.groups === '*') {
          data.target.groups = '*';
        }
      }
      ECHODistributedObject.__super__._copyData.call(this, data);
      return null;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
    	@throw [ECHO.Error] Errors in local validation
     */

    ECHODistributedObject.prototype._buildRequestContents = function () {
      let data,
        group,
        i,
        j,
        l,
        len,
        len1,
        member,
        ref,
        ref1,
        ref2,
        ref3,
        targetGroups,
        targetMembers;
      data = ECHODistributedObject.__super__._buildRequestContents.call(this);
      if ((data.distributed != null) instanceof Date) {
        data.distributed = stringFromDate(data.distributed);
      }
      if ((((ref = data.target) != null ? ref.members : void 0) != null) || (((ref1 = data.target) != null ? ref1.groups : void 0) != null)) {
        if (typeIsArray(data.target.members)) {
          targetMembers = [];
          ref2 = data.target.members;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            member = ref2[i];
            if (member instanceof ECHO.Members.MemberObject) {
              if (member.refid.length > 0) {
                targetMembers.push(member.refid);
              }
            } else if (member === '*') {
              data.target.members = '*';
              break;
            }
          }
          data.target.members = targetMembers;
        }
        if (typeIsArray(data.target.groups)) {
          targetGroups = [];
          ref3 = data.target.groups;
          for (i = l = 0, len1 = ref3.length; l < len1; i = ++l) {
            group = ref3[i];
            if (group instanceof ECHO.Members.GroupObject) {
              if (group.refid.length > 0) {
                targetGroups.push(group.refid);
              }
            } else if (group === '*') {
              data.target.groups = '*';
              break;
            }
          }
          data.target.groups = targetGroups;
        }
      }
      return data;
    };

    return ECHODistributedObject;
  }(ECHODataObject));


  /*
  A global configuration handler in the SDK.
   */

  ECHO = (function () {
    function ECHO() {}

    ECHO.secureDomain = null;

    ECHO.appId = null;

    ECHO.appKey = null;

    ECHO.accessToken = null;


    /*
    	<span class="en">Initializes the configuration. This method must be called before using the SDK.</span>
    	<span class="ja">SDKを初期化します。 SDKを使用する前に必ず呼び出してください。</span>

    	@param [String] secureDomain <span class="en">ECHO account ID (e.g. hogehoge.echopf.com)</span><span class="ja">アカウントID（セキュアドメイン）</span>
    	@param [String] appId <span class="en">application ID</span><span class="ja">アプリケーションID</span>
    	@param [String] appKey <span class="en">application key</span><span class="ja">アプリケーションキー</span>
    	@throw [TypeError]
     */

    ECHO.initialize = function (secureDomain, appId, appKey) {
      if ((secureDomain == null) || !secureDomain) {
        throw new TypeError('argument `secureDomain` must not be null.');
      }
      if ((appId == null) || !appId) {
        throw new TypeError('argument `appId` must not be null.');
      }
      if ((appKey == null) || !appKey) {
        throw new TypeError('argument `appKey` must not be null.');
      }
      ECHO.secureDomain = secureDomain;
      ECHO.appId = appId;
      ECHO.appKey = appKey;
    };

    return ECHO;
  }());


  /*
  <span class="en">Composes a list with paginate data.</span>
  <span class="ja">ページ送り情報が付属したリストを構成します。</span>
   */

  ECHO.List = (function (superClass) {
    extend(List, superClass);

    List.prototype.page = null;

    List.prototype.prevPage = null;

    List.prototype.nextPage = null;

    List.prototype.pageCount = null;

    List.prototype.count = null;

    List.prototype.limit = null;

    List.prototype.order = null;

    List.prototype.asc = null;


    /*
    	Constructs a new ECHOList.

    	@param [Object] data a copying paginate data
     */

    function List(data) {
      if (!(data instanceof Object)) {
        throw new TypeError('Invalid data type for argument `data`.');
      }
      List.__super__.constructor.call(this);
      this.page = data.page;
      this.prevPage = data.prevPage;
      this.nextPage = data.nextPage;
      this.pageCount = data.pageCount;
      this.count = data.count;
      this.limit = data.limit;
      this.order = data.order;
      this.asc = data.asc;
    }

    return List;
  }(Array));


  /*
  An ECHO.Error represents exceptions or errors occurred in the SDK.
   */

  ECHO.Error = (function (superClass) {
    extend(Error, superClass);

    Error.APPID_NOT_SPECIFIED = 100010;

    Error.APPKEY_NOT_SPECIFIED = 100020;

    Error.INVALID_API_APPLICATION = 100030;

    Error.RESOURCE_NOT_FOUND = 110010;

    Error.NOTFOUND_OR_FORBIDDEN = 110020;

    Error.METHOD_NOT_ALLOWED = 110030;

    Error.UNSUPPORTED_MEDIA_TYPE = 110040;

    Error.INVALID_JSON_FORMAT = 110050;

    Error.OPERATION_NOT_PERMITTED = 130000;

    Error.AUTHENTICATION_ERROR = 130010;

    Error.ACCESSTOKEN_INCORRECTED_OR_EXPIRED = 130020;

    Error.READ_ONLY = 130030;

    Error.VALIDATION_ERRORS_OCCURRED = 150000;

    Error.NOT_SET = 150010;

    Error.CONTAINED_RESTRICTED_CHARACTER = 150020;

    Error.TOO_LONG = 150030;

    Error.TOO_SHORT = 150031;

    Error.NON_UNIQUE = 150040;

    Error.CONTAINED_NON_NUMERIC_CHARACTER = 150050;

    Error.EXCEED_ACCEPTABLE_RANGE = 150051;

    Error.NOT_A_PERCENTAGE = 150052;

    Error.INVALID_EMAIL_FORMAT = 150060;

    Error.REFERENCE_LOOPED = 150070;

    Error.INVALID_PHONE_NUMBER_FORMAT = 150080;

    Error.INVALID_DATE_STRING_FORMAT = 150090;

    Error.INVALID_ZIPCODE_FORMAT = 150100;

    Error.REFERENCE_NOT_EXIST = 150110;

    Error.INVALID_PREF_FORMAT = 150120;

    Error.INVALID_VALUE = 150130;

    Error.INVALID_FIELD_REFID = 150140;

    Error.prototype.name = 'ECHO.Error';

    Error.prototype.code = null;

    Error.prototype.message = null;

    Error.prototype.details = {};


    /*
    	Constructs a new ECHO.Error with a particular error code.

    	@param [int] code error code
    	@param [String] message error message
     */

    function Error(code1, message1) {
      this.code = code1;
      this.message = message1;
      this.details = {};
      Error.__super__.constructor.call(this);
    }


    /*
    	Sets a new ECHO.Error into the details of this error
     */

    Error.prototype.setErrorDetail = function (key, code, message) {
      return this.details[key] = new ECHO.Error(code, message);
    };

    return Error;
  }(Error));


  /*
  An ECHO.File is a file object.
   */

  ECHO.File = (function () {
    /*
    	<span class="en">Constructs a new ECHO.File.</span>
    	<span class="ja">新しいファイルオブジェクトを生成します。</span>

    	@param [String] name the name of this file
    	@param [Blob] file raw data
    	@param [File] file raw data
    	@param [Buffer] file raw data if running on node.js
    	@param [String] file string data
    	@param [String] mimeType
     */
    function File(name1, file1, mimeType) {
      this.name = name1 != null ? name1 : null;
      this.file = file1 != null ? file1 : null;
      this.mimeType = mimeType != null ? mimeType : null;
      this.url = null;
    }


    /*
    	<span class="en">Sets a remote file.</span>
    	<span class="ja">リモートファイルをセット。</span>

    	@param [Object] data <span class="en">a remote file object</span><span class="ja">サーバーから取得したリモートファイルオブジェクト</span>
     */

    File.prototype.setRemoteFile = function (data) {
      this.name = data.name;
      return this.url = data.url;
    };


    /*
    	Gets content type of this file.

    	@return [String]
     */

    File.prototype.getMimeType = function () {
      let extension,
        ref,
        ref1;
      if ((this.mimeType != null) && this.mimeType) {
        return this.mimeType;
      }
      extension = /\.([^.]*)$/.exec((ref = this.name) != null ? ref : '');
      if (extension) {
        extension = extension[1].toLowerCase();
      }
      return (ref1 = ECHO.File.mimeTypes[extension]) != null ? ref1 : 'text/plain';
    };

    File.mimeTypes = {
      ai: 'application/postscript',
      aif: 'audio/x-aiff',
      aifc: 'audio/x-aiff',
      aiff: 'audio/x-aiff',
      asc: 'text/plain',
      atom: 'application/atom+xml',
      au: 'audio/basic',
      avi: 'video/x-msvideo',
      bcpio: 'application/x-bcpio',
      bin: 'application/octet-stream',
      bmp: 'image/bmp',
      cdf: 'application/x-netcdf',
      cgm: 'image/cgm',
      class: 'application/octet-stream',
      cpio: 'application/x-cpio',
      cpt: 'application/mac-compactpro',
      csh: 'application/x-csh',
      css: 'text/css',
      dcr: 'application/x-director',
      dif: 'video/x-dv',
      dir: 'application/x-director',
      djv: 'image/vnd.djvu',
      djvu: 'image/vnd.djvu',
      dll: 'application/octet-stream',
      dmg: 'application/octet-stream',
      dms: 'application/octet-stream',
      doc: 'application/msword',
      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
      docm: 'application/vnd.ms-word.document.macroEnabled.12',
      dotm: 'application/vnd.ms-word.template.macroEnabled.12',
      dtd: 'application/xml-dtd',
      dv: 'video/x-dv',
      dvi: 'application/x-dvi',
      dxr: 'application/x-director',
      eps: 'application/postscript',
      etx: 'text/x-setext',
      exe: 'application/octet-stream',
      ez: 'application/andrew-inset',
      gif: 'image/gif',
      gram: 'application/srgs',
      grxml: 'application/srgs+xml',
      gtar: 'application/x-gtar',
      hdf: 'application/x-hdf',
      hqx: 'application/mac-binhex40',
      htm: 'text/html',
      html: 'text/html',
      ice: 'x-conference/x-cooltalk',
      ico: 'image/x-icon',
      ics: 'text/calendar',
      ief: 'image/ief',
      ifb: 'text/calendar',
      iges: 'model/iges',
      igs: 'model/iges',
      jnlp: 'application/x-java-jnlp-file',
      jp2: 'image/jp2',
      jpe: 'image/jpeg',
      jpeg: 'image/jpeg',
      jpg: 'image/jpeg',
      js: 'application/x-javascript',
      kar: 'audio/midi',
      latex: 'application/x-latex',
      lha: 'application/octet-stream',
      lzh: 'application/octet-stream',
      m3u: 'audio/x-mpegurl',
      m4a: 'audio/mp4a-latm',
      m4b: 'audio/mp4a-latm',
      m4p: 'audio/mp4a-latm',
      m4u: 'video/vnd.mpegurl',
      m4v: 'video/x-m4v',
      mac: 'image/x-macpaint',
      man: 'application/x-troff-man',
      mathml: 'application/mathml+xml',
      me: 'application/x-troff-me',
      mesh: 'model/mesh',
      mid: 'audio/midi',
      midi: 'audio/midi',
      mif: 'application/vnd.mif',
      mov: 'video/quicktime',
      movie: 'video/x-sgi-movie',
      mp2: 'audio/mpeg',
      mp3: 'audio/mpeg',
      mp4: 'video/mp4',
      mpe: 'video/mpeg',
      mpeg: 'video/mpeg',
      mpg: 'video/mpeg',
      mpga: 'audio/mpeg',
      ms: 'application/x-troff-ms',
      msh: 'model/mesh',
      mxu: 'video/vnd.mpegurl',
      nc: 'application/x-netcdf',
      oda: 'application/oda',
      ogg: 'application/ogg',
      pbm: 'image/x-portable-bitmap',
      pct: 'image/pict',
      pdb: 'chemical/x-pdb',
      pdf: 'application/pdf',
      pgm: 'image/x-portable-graymap',
      pgn: 'application/x-chess-pgn',
      pic: 'image/pict',
      pict: 'image/pict',
      png: 'image/png',
      pnm: 'image/x-portable-anymap',
      pnt: 'image/x-macpaint',
      pntg: 'image/x-macpaint',
      ppm: 'image/x-portable-pixmap',
      ppt: 'application/vnd.ms-powerpoint',
      pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      potx: 'application/vnd.openxmlformats-officedocument.presentationml.template',
      ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
      ppam: 'application/vnd.ms-powerpoint.addin.macroEnabled.12',
      pptm: 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',
      potm: 'application/vnd.ms-powerpoint.template.macroEnabled.12',
      ppsm: 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',
      ps: 'application/postscript',
      qt: 'video/quicktime',
      qti: 'image/x-quicktime',
      qtif: 'image/x-quicktime',
      ra: 'audio/x-pn-realaudio',
      ram: 'audio/x-pn-realaudio',
      ras: 'image/x-cmu-raster',
      rdf: 'application/rdf+xml',
      rgb: 'image/x-rgb',
      rm: 'application/vnd.rn-realmedia',
      roff: 'application/x-troff',
      rtf: 'text/rtf',
      rtx: 'text/richtext',
      sgm: 'text/sgml',
      sgml: 'text/sgml',
      sh: 'application/x-sh',
      shar: 'application/x-shar',
      silo: 'model/mesh',
      sit: 'application/x-stuffit',
      skd: 'application/x-koan',
      skm: 'application/x-koan',
      skp: 'application/x-koan',
      skt: 'application/x-koan',
      smi: 'application/smil',
      smil: 'application/smil',
      snd: 'audio/basic',
      so: 'application/octet-stream',
      spl: 'application/x-futuresplash',
      src: 'application/x-wais-source',
      sv4cpio: 'application/x-sv4cpio',
      sv4crc: 'application/x-sv4crc',
      svg: 'image/svg+xml',
      swf: 'application/x-shockwave-flash',
      t: 'application/x-troff',
      tar: 'application/x-tar',
      tcl: 'application/x-tcl',
      tex: 'application/x-tex',
      texi: 'application/x-texinfo',
      texinfo: 'application/x-texinfo',
      tif: 'image/tiff',
      tiff: 'image/tiff',
      tr: 'application/x-troff',
      tsv: 'text/tab-separated-values',
      txt: 'text/plain',
      ustar: 'application/x-ustar',
      vcd: 'application/x-cdlink',
      vrml: 'model/vrml',
      vxml: 'application/voicexml+xml',
      wav: 'audio/x-wav',
      wbmp: 'image/vnd.wap.wbmp',
      wbmxl: 'application/vnd.wap.wbxml',
      wml: 'text/vnd.wap.wml',
      wmlc: 'application/vnd.wap.wmlc',
      wmls: 'text/vnd.wap.wmlscript',
      wmlsc: 'application/vnd.wap.wmlscriptc',
      wrl: 'model/vrml',
      xbm: 'image/x-xbitmap',
      xht: 'application/xhtml+xml',
      xhtml: 'application/xhtml+xml',
      xls: 'application/vnd.ms-excel',
      xml: 'application/xml',
      xpm: 'image/x-xpixmap',
      xsl: 'application/xml',
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
      xlsm: 'application/vnd.ms-excel.sheet.macroEnabled.12',
      xltm: 'application/vnd.ms-excel.template.macroEnabled.12',
      xlam: 'application/vnd.ms-excel.addin.macroEnabled.12',
      xlsb: 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',
      xslt: 'application/xslt+xml',
      xul: 'application/vnd.mozilla.xul+xml',
      xwd: 'image/x-xwindowdump',
      xyz: 'chemical/x-xyz',
      zip: 'application/zip',
    };

    return File;
  }());


  /*
  <span class="en">An ECHO.Promise is returned by async methods as a hook to provide callbacks to be called when the async task is fulfilled.</span>
  <span class="ja">非同期処理メソッドの返り値であるPromiseの定義。Promise終了後に実行したいコールバックを設定できます。</span>
   */

  ECHO.Promise = (function () {
    function Promise() {
      this._resolved = false;
      this._rejected = false;
      this._resolvedCallbacks = [];
      this._rejectedCallbacks = [];
      this._error = null;
      this._result = null;
    }


    /*
    	<span class="en">Returns true iff the given object fulfils the Promise interface.</span>
    	<span class="ja">与えられたオブジェクトが、Promiseであるか判定します。</span>

    	@param [Object] promise
    	@return [boolean]
     */

    Promise.is = function (promise) {
      return typeof (promise != null ? promise.then : void 0) === 'function';
    };


    /*
    	<span class="en">Returns a new promise that is resolved with a given value.</span>
    	<span class="ja">渡された値で解決された新しいPromiseを返します。</span>

    	@return [ECHO.Promise]
     */

    Promise.as = function () {
      let promise;
      promise = new ECHO.Promise();
      promise.resolve(...arguments);
      return promise;
    };


    /*
    	<span class="en">Returns a new promise that is rejected with a given error.</span>
    	<span class="ja">失敗したPromiseを、渡されたエラーとともに返します。</span>

    	@return [ECHO.Promise]
     */

    Promise.error = function () {
      let promise;
      promise = new ECHO.Promise();
      promise.reject(...arguments);
      return promise;
    };


    /*
    	<span class="en">Returns a new promise that is fulfilled when all of the input promises are resolved.</span>
    	<span class="ja">渡されたプロミスがすべて解決したら、新しいPromiseを返します。</span>

    	@param [Array<ECHO.Promise>] promises
    	@return [ECHO.Promise]
     */

    Promise.when = function (promises) {
      let errors,
        hadError,
        i,
        j,
        len,
        object,
        objects,
        promise,
        resolveOne,
        results,
        total;
      if ((promises != null ? promises.length : void 0) != null) {
        objects = promises;
      } else {
        objects = arguments;
      }
      total = objects.length;
      hadError = false;
      results = [];
      errors = [];
      results.length = objects.length;
      errors.length = objects.length;
      if (total === 0) {
        return ECHO.Promise.as.apply(this, results);
      }
      promise = new ECHO.Promise();
      resolveOne = function () {
        total -= 1;
        if (total === 0) {
          if (hadError) {
            return promise.reject(errors);
          }
          return promise.resolve(...results);
        }
      };
      for (i = j = 0, len = objects.length; j < len; i = ++j) {
        object = objects[i];
        if (ECHO.Promise.is(object)) {
          object.then(((result) => {
            results[i] = result;
            return resolveOne();
          }), ((error) => {
              errors[i] = error;
              hadError = true;
              return resolveOne();
            }));
        } else {
          results[i] = object;
          resolveOne();
        }
      }
      return promise;
    };


    /*
    	<span class="en">Marks this promise as fulfilled, firing any callbacks waiting on it.</span>
    	<span class="ja">Promiseを解決させ、解決時のコールバックを実行する。</span>

    	@param [Object] result <span class="en">the result to pass to the callbacks</span><span class="ja">コールバックに渡す結果</span>
     */

    Promise.prototype.resolve = function (result) {
      let j,
        len,
        ref,
        ref1,
        resolvedCallback;
      if (this._resolved || this._rejected) {
        throw new Error((ref = `The promise had already been${this._resolved}`) != null ? ref : {
          resolved: 'rejected' + '.',
        });
      }
      this._resolved = true;
      this._result = arguments;
      ref1 = this._resolvedCallbacks;
      for (j = 0, len = ref1.length; j < len; j++) {
        resolvedCallback = ref1[j];
        resolvedCallback.apply(this, this._result);
      }
      this._resolvedCallbacks = [];
      return this._rejectedCallbacks = [];
    };


    /*
    	<span class="en">Marks this promise as fulfilled, firing any callbacks waiting on it.</span>
    	<span class="ja">Promiseを失敗させ、失敗時のコールバックを実行する。</span>

    	@param [Object] error <span class="en">the error to pass to the callbacks</span><span class="ja">コールバックに渡すエラー</span>
     */

    Promise.prototype.reject = function (error) {
      let j,
        len,
        ref,
        ref1,
        rejectedCallback;
      if (this._resolved || this._rejected) {
        throw new Error((ref = `The promise had already been${this._resolved}`) != null ? ref : {
          resolved: 'rejected' + '.',
        });
      }
      this._rejected = true;
      this._error = error;
      ref1 = this._rejectedCallbacks;
      for (j = 0, len = ref1.length; j < len; j++) {
        rejectedCallback = ref1[j];
        rejectedCallback(error);
      }
      this._resolvedCallbacks = [];
      return this._rejectedCallbacks = [];
    };


    /*
    	<span class="en">Adds callbacks to be called when this promise is fulfilled. Returns a new Promise that will be fulfilled when the resolved callback is complete.</span>
    	<span class="ja">Promiseが終了した後に実行されるコールバックを追加します。返却される新しいPromiseは、成功コールバックが完了した後に解決されます。 </span>

    	@param [Function] resolvedCallback 解決時のコールバック
    	@param [Function] rejectedCallback 失敗時のコールバック
     */

    Promise.prototype.then = function (resolvedCallback, rejectedCallback) {
      let promise,
        wrappedRejectedCallback,
        wrappedResolvedCallback;
      promise = new ECHO.Promise();
      wrappedResolvedCallback = function () {
        let result;
        result = arguments;
        if (resolvedCallback) {
          result = [resolvedCallback.apply(this, result)];
        }
        if (result.length === 1 && ECHO.Promise.is(result[0])) {
          return result[0].then((function () {
            return promise.resolve(...arguments);
          }), (error => promise.reject(...error)));
        }
        return promise.resolve(...result);
      };
      wrappedRejectedCallback = function (error) {
        let result;
        result = [];
        if (rejectedCallback) {
          result = [rejectedCallback(error)];
          if (result.length === 1 && ECHO.Promise.is(result[0])) {
            return result[0].then((function () {
              return promise.resolve(...arguments);
            }), (error => promise.reject(error)));
          }
          return promise.reject(result[0]);
        }
        return promise.reject(error);
      };
      if (this._resolved) {
        wrappedResolvedCallback.apply(this, this._result);
      } else if (this._rejected) {
        wrappedRejectedCallback(this._error);
      } else {
        this._resolvedCallbacks.push(wrappedResolvedCallback);
        this._rejectedCallbacks.push(wrappedRejectedCallback);
      }
      return promise;
    };

    return Promise;
  }());


  /*
  An ECHO.ACL expresses ACL to an object.
   */

  ECHO.ACL = (function () {
    /*
    	Constructs a new ECHO.ACL object.

    	@param [Object] aclObj a source object
     */
    function ACL(aclObj) {
      if (aclObj == null) {
        aclObj = null;
      }
      this._all = null;
      this._allMembers = {};
      this._specificGroups = {};
      this._specificMembers = {};
      if (aclObj != null) {
        this._copyData(aclObj);
      }
    }


    /*
    	<span class="en">Gets the ACL entry for all the visitors.</span>
    	<span class="ja">すべての訪問者に与えられているACLを取得。</span>

    	@return [ECHO.ACL.Entry]
     */

    ACL.prototype.getEntryForAll = function () {
      return this._all;
    };


    /*
    	<span class="en">Sets an ACL entry for all the visitors.</span>
    	<span class="ja">すべての訪問者に対するACLをセット。</span>

    	@param [ECHO.ACL.Entry] entry
    	@throw [TypeError]
     */

    ACL.prototype.putEntryForAll = function (entry) {
      this._checkACLEntry(entry);
      this._all = entry;
      return null;
    };


    /*
    	<span class="en">Resets the ACL entry for all the visitors.</span>
    	<span class="ja">すべての訪問者に対するACLをリセット。</span>
     */

    ACL.prototype.resetEntryForAll = function () {
      this._all = null;
      return null;
    };


    /*
    	<span class="en">Gets the ACL entry for all the members belonged to a specific member instance.</span>
    	<span class="ja">特定のインスタンスに所属するメンバーに与えられているACLを取得。</span>

    	@param [String] memberInstanceId <span class="en">the reference ID of the member instance</span><span class="ja">メンバーインスタンスID</span>
    	@return [ECHO.ACL.Entry]
    	@throw [TypeError]
     */

    ACL.prototype.getEntryForAllMembers = function (memberInstanceId) {
      let ref;
      this._checkMemberInstanceId(memberInstanceId);
      return (ref = this._allMembers[memberInstanceId]) != null ? ref : null;
    };


    /*
    	<span class="en">Sets an ACL entry for all the members belonged to a specific member instance.</span>
    	<span class="ja">特定のインスタンスに所属するメンバーに対するACLをセット。</span>

    	@param [String] memberInstanceId <span class="en">the reference ID of the member instance</span><span class="ja">メンバーインスタンスID</span>
    	@param [ECHO.ACL.Entry] entry
    	@throw [TypeError]
     */

    ACL.prototype.putEntryForAllMembers = function (memberInstanceId, entry) {
      this._checkMemberInstanceId(memberInstanceId);
      this._checkACLEntry(entry);
      this._allMembers[memberInstanceId] = entry;
      return null;
    };


    /*
    	<span class="en">Resets the ACL entry for all the members belonged to a specific member instance.</span>
    	<span class="ja">特定のインスタンスに所属するメンバーに対するACLをリセット。</span>

    	@param [String] memberInstanceId <span class="en">the reference ID of the member instance</span><span class="ja">メンバーインスタンスID</span>
    	@throw [TypeError]
     */

    ACL.prototype.resetEntryForAllMembers = function (memberInstanceId) {
      this._checkMemberInstanceId(memberInstanceId);
      delete this._allMembers[memberInstanceId];
      return null;
    };


    /*
    	<span class="en">Gets the ACL entry for all the members belonged to a specific group.</span>
    	<span class="ja">特定のグループに所属するメンバーに与えられているACLを取得。</span>

    	@param [ECHO.Members.GroupObject] group <span class="en">the target ECHOMembersGroupObject</span><span class="ja">対象となるグループオブジェクト</span>
    	@return [ECHO.ACL.Entry]
    	@throw [TypeError]
     */

    ACL.prototype.getEntryForSpecificGroup = function (group) {
      let hash,
        ref;
      hash = this._checkGroupObject(group);
      return (ref = this._specificGroups[hash]) != null ? ref : null;
    };


    /*
    	<span class="en">Sets the ACL entry for all the members belonged to a specific group.</span>
    	<span class="ja">特定のグループに所属するメンバーに対するACLをセット。</span>

    	@param [ECHO.Members.GroupObject] group <span class="en">the target ECHOMembersGroupObject</span><span class="ja">対象となるグループオブジェクト</span>
    	@param [ECHO.ACL.Entry] entry
    	@throw [TypeError]
     */

    ACL.prototype.putEntryForSpecificGroup = function (group, entry) {
      let hash;
      hash = this._checkGroupObject(group);
      this._checkACLEntry(entry);
      this._specificGroups[hash] = entry;
      return null;
    };


    /*
    	<span class="en">Resets the ACL entry for all the members belonged to a specific group.</span>
    	<span class="ja">特定のグループに所属するメンバーに対するACLをリセット。</span>

    	@param [ECHO.Members.GroupObject] group <span class="en">the target ECHOMembersGroupObject</span><span class="ja">対象となるグループオブジェクト</span>
    	@throw [TypeError]
     */

    ACL.prototype.resetEntryForSpecificGroup = function (group) {
      let hash;
      hash = this._checkGroupObject(group);
      delete this._specificGroups[hash];
      return null;
    };


    /*
    	<span class="en">Gets the ACL entry for a specific member.</span>
    	<span class="ja">特定のメンバーに与えられているACLを取得。</span>

    	@param [ECHO.Members.MemberObject] member <span class="en">the target ECHOMemberObject</span><span class="ja">対象となるメンバーオブジェクト</span>
    	@return [ECHO.ACL.Entry]
    	@throw [TypeError]
     */

    ACL.prototype.getEntryForSpecificMember = function (member) {
      let hash,
        ref;
      hash = this._checkMemberObject(member);
      return (ref = this._specificMembers[hash]) != null ? ref : null;
    };


    /*
    	<span class="en">Sets the ACL entry for a specific member.</span>
    	<span class="ja">特定のメンバーに対するACLをセット。</span>

    	@param [ECHO.Members.MemberObject] member <span class="en">the target ECHOMemberObject</span><span class="ja">対象となるメンバーオブジェクト</span>
    	@param [ECHO.ACL.Entry] entry
    	@throw [TypeError]
     */

    ACL.prototype.putEntryForSpecificMember = function (member, entry) {
      let hash;
      hash = this._checkMemberObject(member);
      this._checkACLEntry(entry);
      this._specificMembers[hash] = entry;
      return null;
    };


    /*
    	<span class="en">Resets the ACL entry for a specific member.</span>
    	<span class="ja">特定のメンバーに対するACLをリセット。</span>

    	@param [ECHO.Members.MemberObject] member <span class="en">the target ECHOMemberObject</span><span class="ja">対象となるメンバーオブジェクト</span>
    	@throw [TypeError]
     */

    ACL.prototype.resetEntryForSpecificMember = function (member) {
      let hash;
      hash = this._checkMemberObject(member);
      delete this._specificMembers[hash];
      return null;
    };


    /*
    	Converts this object into an acceptable object for the API.

    	@return [Object] the formatted object
     */

    ACL.prototype.toObject = function () {
      let e,
        key,
        obj,
        ref,
        ref1,
        ref2,
        ref3,
        s;
      obj = {};
      obj['*'] = (ref = this._all) != null ? typeof ref.toObject === 'function' ? ref.toObject() : void 0 : void 0;
      ref1 = this._allMembers;
      for (key in ref1) {
        e = ref1[key];
        if (obj[key] == null) {
          obj[key] = {};
        }
        obj[key]['*'] = e != null ? typeof e.toObject === 'function' ? e.toObject() : void 0 : void 0;
      }
      ref2 = this._specificGroups;
      for (key in ref2) {
        e = ref2[key];
        s = key.split('/');
        if ((s[0] == null) || (s[1] == null) || !s[0] || !s[1]) {
          continue;
        }
        if (obj[s[0]] == null) {
          obj[s[0]] = {};
        }
        if (obj[s[0]].groups == null) {
          obj[s[0]].groups = {};
        }
        obj[s[0]].groups[s[1]] = typeof e.toObject === 'function' ? e.toObject() : void 0;
      }
      ref3 = this._specificMembers;
      for (key in ref3) {
        e = ref3[key];
        s = key.split('/');
        if ((s[0] == null) || (s[1] == null) || !s[0] || !s[1]) {
          continue;
        }
        if (obj[s[0]] == null) {
          obj[s[0]] = {};
        }
        if (obj[s[0]].members == null) {
          obj[s[0]].members = {};
        }
        obj[s[0]].members[s[1]] = typeof e.toObject === 'function' ? e.toObject() : void 0;
      }
      return obj;
    };


    /*
    	Copies data from an object.

    	@private
    	@param [Object] aclObj the source object
     */

    ACL.prototype._copyData = function (aclObj) {
      let e,
        e2,
        e3,
        group,
        key,
        key2,
        key3,
        member,
        results1;
      if (typeof aclObj !== 'object') {
        return null;
      }
      results1 = [];
      for (key in aclObj) {
        e = aclObj[key];
        if (key === '*') {
          results1.push(this.putEntryForAll(new ECHO.ACL.Entry(e)));
        } else {
          results1.push((function () {
            let results2;
            results2 = [];
            for (key2 in e) {
              e2 = e[key2];
              if (key2 === '*') {
                results2.push(this.putEntryForAllMembers(key, new ECHO.ACL.Entry(e2)));
              } else {
                results2.push((function () {
                  let results3;
                  results3 = [];
                  for (key3 in e2) {
                    e3 = e2[key3];
                    if (key2 === 'members') {
                      member = new ECHO.Members.MemberObject(key, key3);
                      results3.push(this.putEntryForSpecificMember(member, new ECHO.ACL.Entry(e3)));
                    } else if (key2 === 'groups') {
                      group = new ECHO.Members.GroupObject(key, key3);
                      results3.push(this.putEntryForSpecificGroup(group, new ECHO.ACL.Entry(e3)));
                    } else {
                      results3.push(void 0);
                    }
                  }
                  return results3;
                }).call(this));
              }
            }
            return results2;
          }).call(this));
        }
      }
      return results1;
    };


    /*
    	Checks if a member instance id is valid.

    	@private
    	@param [String] memberInstanceId a member instance id
    	@throw [TypeError]
     */

    ACL.prototype._checkMemberInstanceId = function (memberInstanceId) {
      if ((memberInstanceId == null) || !(typeIsString(memberInstanceId)) || !memberInstanceId) {
        throw new TypeError('Invalid data type for argument `memberInstanceId`.');
      }
    };


    /*
    	Checks if an ACL entry is valid.

    	@private
    	@param [ECHO.ACL.Entry] entry an ACL entry
    	@throw [TypeError]
     */

    ACL.prototype._checkACLEntry = function (entry) {
      if (!(entry instanceof ECHO.ACL.Entry)) {
        throw new TypeError('Invalid data type for argument `entry`.');
      }
    };


    /*
    	Checks if a group object is valid.

    	@private
    	@param [ECHO.Members.GroupObject] group a group object
    	@throw [TypeError]
     */

    ACL.prototype._checkGroupObject = function (group) {
      if (!(group instanceof ECHO.Members.GroupObject && (group.instanceId != null) && group.instanceId && (group.refid != null) && group.refid)) {
        throw new TypeError('Invalid data type for argument `group`.');
      }
      return `${group.instanceId}/${group.refid}`;
    };


    /*
    	Checks if a member object is valid.

    	@private
    	@param [ECHO.Members.MemberObject] member a member object
    	@throw [TypeError]
     */

    ACL.prototype._checkMemberObject = function (member) {
      if (!(member instanceof ECHO.Members.MemberObject && (member.instanceId != null) && member.instanceId && (member.refid != null) && member.refid)) {
        throw new TypeError('Invalid data type for argument `member`.');
      }
      return `${member.instanceId}/${member.refid}`;
    };

    return ACL;
  }());


  /*
  An ECHO.ACL.Entry expresses an ACL entry composing an ECHO.ACL object.
   */

  ECHO.ACL.Entry = (function () {
    /*
    	Constructs a new ECHO.ACL.Entry.

    	@param [boolean] get
    	@param [boolean] list
    	@param [boolean] edit
    	@param [boolean] delete
     */
    function Entry(get, list, edit, _delete) {
      let obj,
        ref,
        ref1,
        ref2,
        ref3;
      this.get = get;
      this.list = list;
      this.edit = edit;
      this.delete = _delete;
      if (this.get instanceof Object) {
        obj = this.get;
        this.get = (ref = obj.get) != null ? ref : false;
        this.list = (ref1 = obj.list) != null ? ref1 : false;
        this.edit = (ref2 = obj.edit) != null ? ref2 : false;
        this.delete = (ref3 = obj.delete) != null ? ref3 : false;
      }
    }


    /*
    	Converts this object into an acceptable object for the API.

    	@return [Object] the formatted object
     */

    Entry.prototype.toObject = function () {
      return {
        get: this.get,
        list: this.list,
        edit: this.edit,
        delete: this.delete,
      };
    };

    return Entry;
  }());


  /*
  <span class="en">An ECHO.Installation is a device installation object for push notification.</span>
  <span class="ja">プッシュ通知受信端末オブジェクト。</span>
   */

  ECHO.Installation = (function () {
    /*
    	<span class="en">Constructs a new ECHO.Installation.</span>
    	<span class="ja">新しい端末オブジェクトを生成します。</span>

    	@param [Object] data a source object to copy
     */
    function Installation(data) {
      if (data == null) {
        data = null;
      }
      this.deviceType = null;
      this.deviceToken = null;
      if (data != null) {
        this._copyData(data);
      }
    }


    /*
    	Converts this object into an acceptable object for the API.

    	@return [Object] the formatted object
     */

    Installation.prototype.toObject = function () {
      return {
        device_type: this.deviceType,
        device_token: this.deviceToken,
      };
    };


    /*
    	Copies data from an object.

    	@private
    	@param [Object] data the source object
     */

    Installation.prototype._copyData = function (data) {
      if (typeof data !== 'object') {
        return null;
      }
      if (data.device_token != null) {
        this.deviceToken = data.device_token;
      }
      if (data.device_type != null) {
        return this.deviceType = data.device_type;
      }
    };

    return Installation;
  }());


  /*
  <span class="en">An ECHO.ContentsCategoriesMap expresses a hierarchical category map.</span>
  <span class="ja">ツリー構造をもったカテゴリマップ（ノードにECHO.ContentsCategoryObjectを持つ）。</span>

  @see ECHO.ContentsCategoryObject ECHO.ContentsCategoryObject
   */

  ECHO.ContentsCategoriesMap = (function (superClass) {
    extend(ContentsCategoriesMap, superClass);


    /*
    	<span class="en">Constructs a new ECHO.ContentsCategoriesMap based on an existing *entire* or *sub* one on the remote server.</span>
    	<span class="ja">ルートから最下層までを対象とした全カテゴリマップ、もしくは特定のノードをルートとしたサブカテゴリマップとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which the category map has belonged</span><span class="ja">カテゴリが所属するインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the root node of the existing sub one</span><span class="ja">サブカテゴリマップのルートとなるカテゴリのID</span>
    	@param [Object] data a source object to copy
     */

    function ContentsCategoriesMap(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      ContentsCategoriesMap.__super__.constructor.call(this, instanceId, 'categories', refid, data);
    }


    /*
    	Copies data from an object

    	@private
    	@param [Object] data the source object
     */

    ContentsCategoriesMap.prototype._copyData = function (data) {
      let categories,
        category;
      if (!((data != null ? data.categories : void 0) instanceof Object)) {
        return null;
      }
      categories = data.categories;
      if (this._isSubtree) {
        if (!(categories[0] instanceof Object)) {
          return null;
        }
        category = categories[0];
        if ((category.refid == null) || !category.refid) {
          return null;
        }
        this.children = this._makeChildren(category.children);
        return this.node = new ECHO.ContentsCategoryObject(this.instanceId, category.refid, category);
      }
      return this.children = this._makeChildren(categories);
    };


    /*
    	Builds children recursively

    	@private
    	@param [Array<Object>] categories children object
    	@return [Array<ECHO.ContentsCategoriesMap>]
     */

    ContentsCategoriesMap.prototype._makeChildren = function (categories) {
      let category,
        childList,
        key,
        map;
      childList = [];
      if (categories instanceof Object) {
        for (key in categories) {
          category = categories[key];
          if (!(category instanceof Object)) {
            continue;
          }
          if ((category.refid == null) || !category.refid) {
            continue;
          }
          map = new ECHO.ContentsCategoriesMap(this.instanceId, category.refid, {
            categories: [category],
          });
          childList.push(map);
        }
      }
      return childList;
    };

    return ContentsCategoriesMap;
  }(ECHOTreeMap));


  /*
  <span class="en">An ECHO.ContentsCategoryObject is a particular contents category object.</span>
  <span class="ja">カテゴリオブジェクト。ECHO.ContentsCategoriesMapの構成要素。</span>

  @see ECHO.ContentsCategoriesMap ECHO.ContentsCategoriesMap
   */

  ECHO.ContentsCategoryObject = (function (superClass) {
    extend(ContentsCategoryObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.ContentsCategoryObject.</span>
    	<span class="ja">新しいカテゴリ、もしくは既存のカテゴリとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which this object has belonged</span><span class="ja">既存カテゴリが所属するインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存カテゴリのID</span>
    	@param [Object] data a source object to copy
     */

    function ContentsCategoryObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      ContentsCategoryObject.__super__.constructor.call(this, instanceId, 'categories', refid, data);
      this._newParent = null;
    }


    /*
    	<span class="en">Sets a new parent of this tree node.</span>
    	<span class="ja">新しい親を指定する。</span>

    	@param [ECHO.ContentsCategoryObject] newParent
    	@throw [TypeError]
     */

    ContentsCategoryObject.prototype.setNewParent = function (newParent) {
      if (!(newParent instanceof ECHO.ContentsCategoryObject)) {
        throw new TypeError('Invalid data type for argument `newParent`.');
      }
      return this._newParent = newParent;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
     */

    ContentsCategoryObject.prototype._buildRequestContents = function () {
      let data,
        new_parent_refid,
        ref,
        ref1;
      data = ContentsCategoryObject.__super__._buildRequestContents.call(this);
      new_parent_refid = (ref = (ref1 = this._newParent) != null ? ref1.refid : void 0) != null ? ref : null;
      if (new_parent_refid != null) {
        data.parent_refid = new_parent_refid;
      }
      return data;
    };


    /*
    	Copies data from an object

    	@private
    	@param [Object] data the source object
     */

    ContentsCategoryObject.prototype._copyData = function (data) {
      let base,
        category;
      if (!(data instanceof Object)) {
        return null;
      }
      if (data.categories != null) {
        category = typeof (base = data.categories)[0] === 'function' ? base[0](null) : void 0;
      } else {
        category = data;
      }
      if ((category != null ? category.children : void 0) != null) {
        delete category.children;
      }
      ContentsCategoryObject.__super__._copyData.call(this, category);
      return null;
    };

    return ContentsCategoryObject;
  }(ECHODataObject));


  /*
  <span class="en">An ECHO.Blogs contains query methods to operate a blog instance.</span>
  <span class="ja">ブログインスタンスを操作するクエリ。</span>
   */

  ECHO.Blogs = (function () {
    function Blogs() {}


    /*
    	<span class="en">Finds entries from the remote server.</span>
    	<span class="ja">記事検索。</span>

    	@param [String] instanceId <span class="en">the reference ID of the finding target instance</span><span class="ja">検索対象ブログインスタンスのID</span>
    	@param [Object] params <span class="en">to control the output</span><span class="ja"><a href="http://echopf.com/docs/restapi/list">リスト制御パラメータ</a></span>
    	@return [ECHO.Promise]
     */

    Blogs.find = function (instanceId, params) {
      return ECHOQuery.find(instanceId, 'archive', params, 'entries');
    };

    return Blogs;
  }());


  /*
  <span class="en">An ECHO.Blogs.EntryObject is a particular entry object.</span>
  <span class="ja">記事オブジェクト。</span>
   */

  ECHO.Blogs.EntryObject = (function (superClass) {
    extend(EntryObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Blogs.EntryObject.</span>
    	<span class="ja">新しい記事としてオブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which this object belongs</span><span class="ja">新しい記事を所属させるブログインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存記事のID</span>
    	@param [Object] data a source object to copy
     */

    function EntryObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      EntryObject.__super__.constructor.call(this, instanceId, 'entry', refid, data);
    }


    /*
    	Copies data from an object

    	@private
    	@param [Object] data the source object
     */

    EntryObject.prototype._copyData = function (data) {
      if (data.published != null) {
        data.published = dateFromString(data.published);
      }
      EntryObject.__super__._copyData.call(this, data);
      return null;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
    	@throw [ECHO.Error] Errors in local validation
     */

    EntryObject.prototype._buildRequestContents = function () {
      let data;
      data = EntryObject.__super__._buildRequestContents.call(this);
      if ((data.published != null) instanceof Date) {
        data.published = stringFromDate(data.published);
      }
      return data;
    };

    return EntryObject;
  }(ECHOContentsObject));


  /*
  <span class="en">An ECHO.Databases contains query methods to operate a database instance.</span>
  <span class="ja">データベースインスタンスを操作するクエリ。</span>
   */

  ECHO.Databases = (function () {
    function Databases() {}


    /*
    	<span class="en">Finds records from the remote server.</span>
    	<span class="ja">レコード検索。</span>

    	@param [String] instanceId <span class="en">the reference ID of the finding target instance</span><span class="ja">検索対象データベースインスタンスのID</span>
    	@param [Object] params <span class="en">to control the output</span><span class="ja"><a href="http://echopf.com/docs/restapi/list">リスト制御パラメータ</a></span>
    	@return [ECHO.Promise]
     */

    Databases.find = function (instanceId, params) {
      if (params == null) {
        params = {};
      }
      return ECHOQuery.find(instanceId, 'archive', params, 'records');
    };

    return Databases;
  }());


  /*
  <span class="en">An ECHO.Databases.RecordObject is a particular record object.</span>
  <span class="ja">レコードオブジェクト。</span>
   */

  ECHO.Databases.RecordObject = (function (superClass) {
    extend(RecordObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Databases.RecordObject.</span>
    	<span class="ja">新しいレコード、もしくは既存のレコードとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which this object has belonged</span><span class="ja">既存レコードが所属するブログインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存レコードのID</span>
    	@param [Object] data a source object to copy
     */

    function RecordObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      RecordObject.__super__.constructor.call(this, instanceId, 'record', refid, data);
    }

    return RecordObject;
  }(ECHOContentsObject));


  /*
  <span class="en">An ECHO.Members contains query methods to operate a member instance.</span>
  <span class="ja">メンバーインスタンスを操作するクエリ。</span>
   */

  ECHO.Members = (function (superClass) {
    extend(Members, superClass);

    function Members() {
      return Members.__super__.constructor.apply(this, arguments);
    }


    /*
    	<span class="en">Finds members from the remote server</span>
    	<span class="ja">メンバー検索。</span>

    	@param [String] instanceId <span class="en">the reference ID of the finding target instance</span><span class="ja">検索対象メンバーインスタンスのID</span>
    	@param [Object] params <span class="en">to control the output</span><span class="ja"><a href="http://echopf.com/docs/restapi/list">リスト制御パラメータ</a></span>
    	@return [ECHO.Promise]
     */

    Members.find = function (instanceId, params) {
      if (params == null) {
        params = {};
      }
      return ECHOQuery.find(instanceId, 'list', params, 'members');
    };


    /*
    	<span class="en">Logs-in in a background thread.</span>
    	<span class="ja">非同期通信によるログイン。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which the login member has belonged</span><span class="ja">ログインメンバーが所属するインスタンスのID</span>
    	@param [String] loginId <span class="en">login id</span><span class="ja">ログインID</span>
    	@param [String] password <span class="en">ログインパスワード</span><span class="ja">ログインパスワード</span>
    	@return [ECHO.Promise]
     */

    Members.login = function (instanceId, loginId, password) {
      let data,
        promise,
        promise2;
      data = {
        login_id: loginId,
        password,
      };
      promise = ECHOQuery.request('POST', `/${instanceId}/login`, data);
      promise2 = new ECHO.Promise();
      promise.then(((retObj) => {
        let member,
          ref;
        if ((retObj != null ? retObj.refid : void 0) == null) {
          return null;
        }
        member = new ECHO.Members.MemberObject(instanceId, retObj.refid, retObj);
        ECHO.accessToken = (ref = retObj.access_token) != null ? ref : null;
        return promise2.resolve(member);
      }), (error => promise2.reject(error)));
      return promise2;
    };


    /*
    	<span class="en">Logs-out in background thread.</span>
    	<span class="ja">非同期通信によるログアウト。</span>
    	@param [String] instanceId <span class="en">the reference ID of the instance to which the login member has belonged</span><span class="ja">ログインメンバーが所属するインスタンスのID</span>
    	@return [ECHO.Promise]
     */

    Members.logout = function (instanceId) {
      let promise,
        promise2;
      promise = ECHOQuery.request('POST', `/${instanceId}/login`, {});
      promise2 = new ECHO.Promise();
      promise.then((retObj => promise2.resolve(null)), (error => promise2.reject(error)));
      return promise2;
    };

    return Members;
  }(ECHODataObject));


  /*
  <span class="en">An ECHO.Members.MemberObject is a particular member object.</span>
  <span class="ja">メンバーオブジェクト。</span>
   */

  ECHO.Members.MemberObject = (function (superClass) {
    extend(MemberObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Members.MemberObject.</span>
    	<span class="ja">新しいメンバー、もしくは既存のメンバーとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which this object has belonged</span><span class="ja">既存メンバーが所属するメンバーインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存メンバーのID</span>
    	@param [Object] data a source object to copy
     */

    function MemberObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      MemberObject.__super__.constructor.call(this, instanceId, 'member', refid, data);
    }


    /*
    	Copies data from an object.

    	@private
    	@param [Object] data the source object
     */

    MemberObject.prototype._copyData = function (data) {
      let group,
        i,
        j,
        len,
        ref;
      if (data.last_logined != null) {
        data.last_logined = dateFromString(data.last_logined);
      }
      if (data.groups != null) {
        ref = data.groups;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          group = ref[i];
          if (group.refid != null) {
            data.groups[i] = new ECHO.Members.GroupObject(this.instanceId, group.refid, group);
          }
        }
      }
      if (data.installation != null) {
        data.installation = new ECHO.Installation(data.installation);
      }
      MemberObject.__super__._copyData.call(this, data);
      return null;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
    	@throw [ECHO.Error] Errors in local validation
     */

    MemberObject.prototype._buildRequestContents = function () {
      let data,
        group,
        i,
        j,
        len,
        ref;
      data = MemberObject.__super__._buildRequestContents.call(this);
      delete (data.last_logined != null);
      if (data.groups != null) {
        ref = data.groups;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          group = ref[i];
          if (group.refid != null) {
            data.groups[i] = group.refid;
          }
        }
      }
      if ((data.installation != null) && data.installation instanceof ECHO.Installation) {
        data.installation = data.installation.toObject();
      }
      return data;
    };

    return MemberObject;
  }(ECHODataObject));


  /*
  <span class="en">An ECHO.Members.GroupsMap expresses a hierachical group map.</span>
  <span class="ja">ツリー構造をもったグループマップ。ノードとしてECHO.Members.GroupObjectを持つ。</span>

  @see ECHO.Members.GroupObject ECHO.Members.GroupObject
   */

  ECHO.Members.GroupsMap = (function (superClass) {
    extend(GroupsMap, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Members.GroupsMap based on an existing *entire* or *sub* one on the remote server.</span>
    	<span class="ja">ルートから最下層までを対象とした全グループマップ、もしくは特定のノードをルートとしたサブグループマップとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which the group map has belonged</span><span class="ja">グループが所属するメンバーインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the root node of the existing sub one</span><span class="ja">サブグループマップのルートとなるグループのID</span>
    	@param [Object] data a source object to copy
     */

    function GroupsMap(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      GroupsMap.__super__.constructor.call(this, instanceId, 'groups', refid, data);
    }


    /*
    	Copies data from an object.

    	@private
    	@param [Object] data the source object
     */

    GroupsMap.prototype._copyData = function (data) {
      let group,
        groups;
      if (!((data != null ? data.groups : void 0) instanceof Object)) {
        return null;
      }
      groups = data.groups;
      if (this._isSubtree) {
        if (!(groups[0] instanceof Object)) {
          return null;
        }
        group = groups[0];
        if ((group.refid == null) || !group.refid) {
          return null;
        }
        this.children = this._makeChildren(group.children);
        return this.node = new ECHO.Members.GroupObject(this.instanceId, group.refid, group);
      }
      return this.children = this._makeChildren(groups);
    };


    /*
    	Builds children recursively

    	@private
    	@param [Array<Object>] groups children object
    	@return [Array<ECHO.Members.GroupObject>]
     */

    GroupsMap.prototype._makeChildren = function (groups) {
      let childList,
        group,
        j,
        len,
        map;
      childList = [];
      if (groups instanceof Object) {
        for (j = 0, len = groups.length; j < len; j++) {
          group = groups[j];
          if (!(group instanceof Object)) {
            return null;
          }
          if (((group != null ? group.refid : void 0) == null) || !group.refid) {
            return null;
          }
          map = new ECHO.Members.GroupsMap(this.instanceId, group.refid, {
            groups: [group],
          });
          childList.push(map);
        }
      }
      return childList;
    };

    return GroupsMap;
  }(ECHOTreeMap));


  /*
  <span class="en">An ECHO.Members.GroupObject is a particular group data.</span>
  <span class="ja">グループオブジェクト。ECHO.Members.GroupsMapの構成要素。</span>

  @see ECHO.Members.GroupsMap ECHO.Members.GroupsMap
   */

  ECHO.Members.GroupObject = (function (superClass) {
    extend(GroupObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Members.GroupObject.</span>
    	<span class="ja">新しいグループ、もしくは既存のグループをオブジェクトとして生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of the instance to which this object has belonged</span><span class="ja">既存グループが所属するメンバーインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存グループのID</span>
    	@param [Object] data a copying group object
     */

    function GroupObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      GroupObject.__super__.constructor.call(this, instanceId, 'groups', refid, data);
      this._newParent = null;
    }


    /*
    	<span class="en">Sets a new parent of this tree node.</span>
    	<span class="ja">新しい親を指定する。</span>

    	@param [ECHO.ContentsCategoryObject] newParent
    	@throw [TypeError]
     */

    GroupObject.prototype.setNewParent = function (newParent) {
      if (!(newParent instanceof ECHO.Members.GroupObject)) {
        throw new TypeError('Invalid data type for argument `newParent`.');
      }
      return this._newParent = newParent;
    };


    /*
    	Builds a request contents object.

    	@private
    	@return [Object]
     */

    GroupObject.prototype._buildRequestContents = function () {
      let data,
        new_parent_refid,
        ref,
        ref1;
      data = GroupObject.__super__._buildRequestContents.call(this);
      new_parent_refid = (ref = (ref1 = this._newParent) != null ? ref1.refid : void 0) != null ? ref : null;
      if (new_parent_refid != null) {
        data.parent_refid = new_parent_refid;
      }
      return data;
    };


    /*
    	Copies data from the specified object

    	@private
    	@param [Object] data
     */

    GroupObject.prototype._copyData = function (data) {
      let base,
        group;
      if (!(data instanceof Object)) {
        return null;
      }
      if (data.groups != null) {
        group = typeof (base = data.groups)[0] === 'function' ? base[0](null) : void 0;
      } else {
        group = data;
      }
      if ((group != null ? group.children : void 0) != null) {
        delete group.children;
      }
      GroupObject.__super__._copyData.call(this, group);
      return null;
    };

    return GroupObject;
  }(ECHODataObject));


  /*
  <span class="en">An ECHO.Members.MailmagObject is a e-mail magazine object.</span>
  <span class="ja">メールマガジンオブジェクト。</span>
   */

  ECHO.Members.MailmagObject = (function (superClass) {
    extend(MailmagObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Members.MailmagObject.</span>
    	<span class="ja">新しいメールマガジン、もしくは既存のメールマガジンとして、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of a member instance</span><span class="ja">メンバーインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存メールマガジンのID</span>
    	@param [Object] data a source object to copy
     */

    function MailmagObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      MailmagObject.__super__.constructor.call(this, instanceId, 'mailmag', refid, data);
    }

    return MailmagObject;
  }(ECHODistributedObject));


  /*
  <span class="en">An ECHO.Members.PushNotificationObject is a push notification object.</span>
  <span class="ja">プッシュ通知オブジェクト。</span>
   */

  ECHO.Members.PushNotificationObject = (function (superClass) {
    extend(PushNotificationObject, superClass);


    /*
    	<span class="en">Constructs a new ECHO.Members.PushNotificationObject.</span>
    	<span class="ja">新しいプッシュ通知、もしくは既存のプッシュ通知として、オブジェクトを生成します。</span>

    	@param [String] instanceId <span class="en">the reference ID of a member instance</span><span class="ja">メンバーインスタンスのID</span>
    	@param [String] refid <span class="en">the reference ID of the existing one</span><span class="ja">既存メールマガジンのID</span>
    	@param [Object] data a source object to copy
     */

    function PushNotificationObject(instanceId, refid, data) {
      if (refid == null) {
        refid = null;
      }
      if (data == null) {
        data = null;
      }
      PushNotificationObject.__super__.constructor.call(this, instanceId, 'push_notification', refid, data);
    }

    return PushNotificationObject;
  }(ECHODistributedObject));

  if (typeof module !== 'undefined' && module !== null ? module.exports : void 0) {
    module.exports = ECHO;
  } else {
    this.ECHO = ECHO;
  }

  typeIsArray = function (value) {
    return value && typeof value === 'object' && value instanceof Array && typeof value.length === 'number' && typeof value.splice === 'function' && !(value.propertyIsEnumerable('length'));
  };

  typeIsString = function (value) {
    return typeof value === 'string' || value instanceof String;
  };

  dateFromString = function (dateStr) {
    let d;
    if (!(typeIsString(dateStr))) {
      throw new TypeError('Invalid data type for argument `dateStr`.');
    }
    d = dateStr.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2}) ([0-9]{2}):([0-9]{2}):([0-9]{2})$/);
    if (d == null) {
      throw new TypeError('Invalid date string format for argument `dateStr`.');
    }
    return new Date(Date.UTC(d[1], d[2] - 1, d[3], d[4], d[5], d[6], 0));
  };

  stringFromDate = function (dateObj) {
    let date,
      hour,
      min,
      month,
      sec,
      year;
    if (!(dateObj instanceof Date)) {
      throw new TypeError('Invalid data type for argument `dateObj`.');
    }
    year = dateObj.getUTCFullYear();
    month = dateObj.getUTCMonth() + 1;
    date = dateObj.getUTCDate();
    hour = dateObj.getUTCHours();
    min = dateObj.getUTCMinutes();
    sec = dateObj.getUTCSeconds();
    return `${year}-${month}-${date} ${hour}:${min}:${sec}`;
  };


  /*
   * Clone an object
  clone = (obj) ->
  	if not obj? or typeof obj isnt 'object'
  		return obj

  	if obj instanceof Date
  		return new Date obj.getTime()

  	if obj instanceof RegExp
  		flags = ''
  		flags += 'g' if obj.global?
  		flags += 'i' if obj.ignoreCase?
  		flags += 'm' if obj.multiline?
  		flags += 'y' if obj.sticky?
  		return new RegExp(obj.source, flags)

  	if Buffer? && obj instanceof Buffer
  		newBuf = new Buffer obj.length
  		obj.copy(newBuf)
  		return newBuf


  	newInstance = new obj.constructor()

  	for key of obj
  		newInstance[key] = clone obj[key]

  	return newInstance
   */
}).call(this);
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

(function () {
  if (typeof module !== 'undefined' && module !== null ? module.exports : void 0) {
    const Url = require('url');
    const spawn = require('child_process').spawn;
    const fs = require('fs');

    XMLHttpRequest = function () {
      /**
   * Private variables
   */
      const self = this;
      const http = require('http');
      const https = require('https');

      // Holds http.js objects
      let request;
      let response;

      // Request settings
      let settings = {};

      // Disable header blacklist.
      // Not part of XHR specs.
      let disableHeaderCheck = false;

      // Set some default headers
      const defaultHeaders = {
        'User-Agent': 'node-XMLHttpRequest',
        Accept: '*/*',
      };

      let headers = defaultHeaders;

      // These headers are not user setable.
      // The following are allowed but banned in the spec:
      // * user-agent
      const forbiddenRequestHeaders = [
        'accept-charset',
        'accept-encoding',
        'access-control-request-headers',
        'access-control-request-method',
        'connection',
        'content-length',
        'content-transfer-encoding',
        'cookie',
        'cookie2',
        'date',
        'expect',
        'host',
        'keep-alive',
        'origin',
        'referer',
        'te',
        'trailer',
        'transfer-encoding',
        'upgrade',
        'via',
      ];

      // These request methods are not allowed
      const forbiddenRequestMethods = [
        'TRACE',
        'TRACK',
        'CONNECT',
      ];

      // Send flag
      let sendFlag = false;
      // Error flag, used when errors occur or abort is called
      let errorFlag = false;

      // Event listeners
      const listeners = {};

      /**
   * Constants
   */

      this.UNSENT = 0;
      this.OPENED = 1;
      this.HEADERS_RECEIVED = 2;
      this.LOADING = 3;
      this.DONE = 4;

      /**
   * Public vars
   */

      // Current state
      this.readyState = this.UNSENT;

      // default ready state change handler in case one is not set or is set late
      this.onreadystatechange = null;

      // Result & response
      this.responseText = '';
      this.responseXML = '';
      this.status = null;
      this.statusText = null;

      /**
   * Private methods
   */

      /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
      const isAllowedHttpHeader = function (header) {
        return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
      };

      /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
      const isAllowedHttpMethod = function (method) {
        return (method && forbiddenRequestMethods.indexOf(method) === -1);
      };

      /**
   * Public methods
   */

      /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
      this.open = function (method, url, async, user, password) {
        this.abort();
        errorFlag = false;

        // Check for valid request method
        if (!isAllowedHttpMethod(method)) {
          throw 'SecurityError: Request method not allowed';
        }

        settings = {
          method,
          url: url.toString(),
          async: (typeof async !== 'boolean' ? true : async),
          user: user || null,
          password: password || null,
        };

        setState(this.OPENED);
      };

      /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
      this.setDisableHeaderCheck = function (state) {
        disableHeaderCheck = state;
      };

      /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
      this.setRequestHeader = function (header, value) {
        if (this.readyState !== this.OPENED) {
          throw 'INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN';
        }
        if (!isAllowedHttpHeader(header)) {
          console.warn(`Refused to set unsafe header "${header}"`);
          return;
        }
        if (sendFlag) {
          throw 'INVALID_STATE_ERR: send flag is true';
        }
        headers[header] = value;
      };

      /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
      this.getResponseHeader = function (header) {
        if (typeof header === 'string'
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
        ) {
          return response.headers[header.toLowerCase()];
        }

        return null;
      };

      /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
      this.getAllResponseHeaders = function () {
        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
          return '';
        }
        let result = '';

        for (const i in response.headers) {
          // Cookie headers are excluded
          if (i !== 'set-cookie' && i !== 'set-cookie2') {
            result += `${i}: ${response.headers[i]}\r\n`;
          }
        }
        return result.substr(0, result.length - 2);
      };

      /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
      this.getRequestHeader = function (name) {
        // @TODO Make this case insensitive
        if (typeof name === 'string' && headers[name]) {
          return headers[name];
        }

        return '';
      };

      /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
      this.send = function (data) {
        if (this.readyState !== this.OPENED) {
          throw 'INVALID_STATE_ERR: connection must be opened before send() is called';
        }

        if (sendFlag) {
          throw 'INVALID_STATE_ERR: send has already been called';
        }

        let ssl = false,
          local = false;
        const url = Url.parse(settings.url);
        let host;
        // Determine the server
        switch (url.protocol) {
          case 'https:':
            ssl = true;
            // SSL & non-SSL both need host, no break here.
          case 'http:':
            host = url.hostname;
            break;

          case 'file:':
            local = true;
            break;

          case undefined:
          case '':
            host = 'localhost';
            break;

          default:
            throw 'Protocol not supported.';
        }

        // Load files off the local filesystem (file://)
        if (local) {
          if (settings.method !== 'GET') {
            throw 'XMLHttpRequest: Only GET method is supported';
          }

          if (settings.async) {
            fs.readFile(url.pathname, 'utf8', (error, data) => {
              if (error) {
                self.handleError(error);
              } else {
                self.status = 200;
                self.responseText = data;
                setState(self.DONE);
              }
            });
          } else {
            try {
              this.responseText = fs.readFileSync(url.pathname, 'utf8');
              this.status = 200;
              setState(self.DONE);
            } catch (e) {
              this.handleError(e);
            }
          }

          return;
        }

        // Default to port 80. If accessing localhost on another port be sure
        // to use http://localhost:port/path
        const port = url.port || (ssl ? 443 : 80);
        // Add query string if one is used
        const uri = url.pathname + (url.search ? url.search : '');

        // Set the Host header or the server may reject the request
        headers.Host = host;
        if (!((ssl && port === 443) || port === 80)) {
          headers.Host += `:${url.port}`;
        }

        // Set Basic Auth if necessary
        if (settings.user) {
          if (typeof settings.password === 'undefined') {
            settings.password = '';
          }
          const authBuf = new Buffer(`${settings.user}:${settings.password}`);
          headers.Authorization = `Basic ${authBuf.toString('base64')}`;
        }

        // Determine whether data is FormData
        const formData = data && data.pipe && data.getHeaders && data.getLengthSync;

        // Set content length header
        if (settings.method === 'GET' || settings.method === 'HEAD') {
          data = null;
        } else if (formData) {
          headers['Content-Length'] = data.getLengthSync();
          headers['Content-Type'] = data.getHeaders()['content-type'];
        } else if (data) {
          headers['Content-Length'] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

          if (!headers['Content-Type']) {
            headers['Content-Type'] = 'text/plain;charset=UTF-8';
          }
        } else if (settings.method === 'POST') {
          // For a post with no data set Content-Length: 0.
          // This is required by buggy servers that don't meet the specs.
          headers['Content-Length'] = 0;
        }

        const options = {
          host,
          port,
          path: uri,
          method: settings.method,
          headers,
          agent: false,
        };

        // Reset error flag
        errorFlag = false;

        // Handle async requests
        if (settings.async) {
          // Use the proper protocol
          const doRequest = ssl ? https.request : http.request;

          // Request is being sent, set send flag
          sendFlag = true;

          // As per spec, this is called here for historical reasons.
          self.dispatchEvent('readystatechange');

          // Handler for the response
          const responseHandler = function responseHandler(resp) {
            // Set response var to the response we got back
            // This is so it remains accessable outside this scope
            response = resp;
            // Check for redirect
            // @TODO Prevent looped redirects
            if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
              // Change URL to the redirect location
              settings.url = response.headers.location;
              const url = Url.parse(settings.url);
              // Set host var in case it's used later
              host = url.hostname;
              // Options for the new request
              const newOptions = {
                hostname: url.hostname,
                port: url.port,
                path: url.path,
                method: response.statusCode === 303 ? 'GET' : settings.method,
                headers,
              };

              // Issue the new request
              request = doRequest(newOptions, responseHandler).on('error', errorHandler);
              request.end();
              // @TODO Check if an XHR event needs to be fired here
              return;
            }

            response.setEncoding('utf8');

            setState(self.HEADERS_RECEIVED);
            self.status = response.statusCode;

            response.on('data', (chunk) => {
              // Make sure there's some data
              if (chunk) {
                self.responseText += chunk;
              }
              // Don't emit state changes if the connection has been aborted.
              if (sendFlag) {
                setState(self.LOADING);
              }
            });

            response.on('end', () => {
              if (sendFlag) {
                // Discard the end event if the connection has been aborted
                setState(self.DONE);
                sendFlag = false;
              }
            });

            response.on('error', (error) => {
              self.handleError(error);
            });
          };

          // Error handler for the request
          var errorHandler = function errorHandler(error) {
            self.handleError(error);
          };

          // Create the request
          request = doRequest(options, responseHandler).on('error', errorHandler);

          // Node 0.4 and later won't accept empty data. Make sure it's needed.
          if (formData) {
      	data.pipe(request);
          } else if (data) {
            request.write(data);
          }

          request.end();

          self.dispatchEvent('loadstart');
        } else { // Synchronous
          // Create a temporary file for communication with the other Node process
          const contentFile = `.node-xmlhttprequest-content-${process.pid}`;
          const syncFile = `.node-xmlhttprequest-sync-${process.pid}`;
          fs.writeFileSync(syncFile, '', 'utf8');
          // The async request the other Node process executes
          const execString = `${"var http = require('http'), https = require('https'), fs = require('fs');"
        + 'var doRequest = http'}${ssl ? 's' : ''}.request;`
        + `var options = ${JSON.stringify(options)};`
        + 'var responseText = \'\';'
        + 'var req = doRequest(options, function(response) {'
        + 'response.setEncoding(\'utf8\');'
        + 'response.on(\'data\', function(chunk) {'
        + '  responseText += chunk;'
        + '});'
        + 'response.on(\'end\', function() {'
        + `fs.writeFileSync('${contentFile}', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');`
        + `fs.unlinkSync('${syncFile}');`
        + '});'
        + 'response.on(\'error\', function(error) {'
        + `fs.writeFileSync('${contentFile}', JSON.stringify({err: error}), 'utf8');`
        + `fs.unlinkSync('${syncFile}');`
        + '});'
        + '}).on(\'error\', function(error) {'
        + `fs.writeFileSync('${contentFile}', JSON.stringify({err: error}), 'utf8');`
        + `fs.unlinkSync('${syncFile}');`
        + `});${
          data ? `req.write('${JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'")}');` : ''
        }req.end();`;
          // Start the other Node Process, executing this string
          const syncProc = spawn(process.argv[0], ['-e', execString]);
          while (fs.existsSync(syncFile)) {
            // Wait while the sync file is empty
          }
          const resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
          // Kill the child process once the file has data
          syncProc.stdin.end();
          // Remove the temporary file
          fs.unlinkSync(contentFile);

          if (resp.err) {
            self.handleError(resp.err);
          } else {
            response = resp.data;
            self.status = resp.data.statusCode;
            self.responseText = resp.data.text;
            setState(self.DONE);
          }
        }
      };

      /**
   * Called when an error is encountered to deal with it.
   */
      this.handleError = function (error) {
        this.status = 503;
        this.statusText = error;
        this.responseText = error.stack;
        errorFlag = true;
        setState(this.DONE);
      };

      /**
   * Aborts a request.
   */
      this.abort = function () {
        if (request) {
          request.abort();
          request = null;
        }

        headers = defaultHeaders;
        this.responseText = '';
        this.responseXML = '';

        errorFlag = true;

        if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
          sendFlag = false;
          setState(this.DONE);
        }
        this.readyState = this.UNSENT;
      };

      /**
   * Adds an event listener. Preferred method of binding to events.
   */
      this.addEventListener = function (event, callback) {
        if (!(event in listeners)) {
          listeners[event] = [];
        }
        // Currently allows duplicate callbacks. Should it?
        listeners[event].push(callback);
      };

      /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
      this.removeEventListener = function (event, callback) {
        if (event in listeners) {
          // Filter will return a new array with the callback removed
          listeners[event] = listeners[event].filter(ev => ev !== callback);
        }
      };

      /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
      this.dispatchEvent = function (event) {
        if (typeof self[`on${event}`] === 'function') {
          self[`on${event}`]();
        }
        if (event in listeners) {
          for (let i = 0, len = listeners[event].length; i < len; i++) {
            listeners[event][i].call(self);
          }
        }
      };

      /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
      var setState = function (state) {
        if (state == self.LOADING || self.readyState !== state) {
          self.readyState = state;

          if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
            self.dispatchEvent('readystatechange');
          }

          if (self.readyState === self.DONE && !errorFlag) {
            self.dispatchEvent('load');
            // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
            self.dispatchEvent('loadend');
          }
        }
      };
    };
  }
}).call(this);
